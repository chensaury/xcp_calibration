/*----------------------------------------------------------------------------- */
/* vx1000_mpc5xxx_cfg.h */
/* Program instrumentation for Vector VX with a FSL/STM xPC5xxx */
/* Version 2.4 30.06.2011 */
/* Vector Informatik GmbH */
/* */
/* User specific configuration parameters */
/*----------------------------------------------------------------------------- */

#if !defined(VX1000_MPC5XXX_CFG_H)
#define VX1000_MPC5XXX_CFG_H


/* Define the memory section were the global VX1000 data is placed */
/* The address of the variable gVX1000 in this memory section must be specified in the VX1000 configuration ! */
/* The memory section must be part of a trace window ! */
/* For Nexus Class 2+ or for Bypassing, the memory section must not be cached */

#define VX1000_MEMORY_SECTION __attribute__((section("vx1000"))) /* This is specific for the GNU compiler */


/*----------------------------------------------------------------------------- */
/* On dual core systems, define an appropriate mutex mechanism to interlock code running on different cores */


/*#define VX1000_ENTER_SPINLOCK() */
/*#define VX1000_LEAVE_SPINLOCK() */


/*----------------------------------------------------------------------------- */
/* Define the target ECU identification string (XCP GET_ID) */
/* This is optional */
/* Is used by CANape to autodetect the A2L file name */

#define VX1000_ECUID         "XCPDemo"
#define VX1000_ECUID_LEN     7           /* number of actual characters in VX1000_ECUID (_no_ trailing '\0'! */




/*----------------------------------------------------------------------------- */
/* Timestamp clock */

/* A timestamp clock is needed if  */
/*   1. If DAQ over DATA TRACE is used and timestamps generated by the ECU are desired */
/*   2. If DAQ over JTAG is used (for Nexus class 2+) */
/*   3. To check bypass timeouts */
/* Note that there is no method to create a free running timer without impact */
/* to the application, so it is up to the user to implement that */

/* Define any free running 32 Bit timer here and specifiy the resolution */

/* #define VX1000_CLOCK_TICKS_PER_US resolution_of_the_free_runing_timer   */
/* #define VX1000_CLOCK() function_which_returns_a_free_running_timer()  */





/* Buildin examples (obsolete code in VX1000_MPC5xxx.c): */

/* 1. Use a clock derived from a free runing EMIOS channel */
/*    Note that this requires initialization if the EMIOS */
/*#define VX1000_CLOCK_EMIOS_CHANNEL 13 */

/* 2. Use the PowerPC core timebase unit as clock */
/*    Note that this is a supervisor level special function register */
/*    and requires initialization of the PPC core HID0 register */
/*    and not all PPC cores support this feature  */
#define VX1000_CLOCK_TB
#define VX1000_CLOCK_TICKS_PER_US 128UL   




/*----------------------------------------------------------------------------- */
/* Define parameters for measurement with daq display tables (OLDA) */
/* Needed if NEXUS class 3 data trace is unavailable, requires NEXUS class 2+ */

/* Turn on OLDA daq  */
#define VX1000_OLDA
#if defined(VX1000_OLDA)

/* Define the memory size for the OLDA daq transfer tables */
/* Size needs to be at least the amount of measurement data + 4 Byte for each memory gap */
//#define VX1000_OLDA_MEMORY_SIZE 0xC00 /* Size in Bytes */

/* Share the memory with the XCP on CAN driver */
#include "XCPBasic.h"
#define VX1000_OLDA_MEMORY_SIZE sizeof(xcp.Daq) /* Size in Bytes */
#define VX1000_OLDA_MEMORY_ADDR ((unsigned int)&xcp.Daq) /* Addr */

/* Turn on benchmarking of the event copy durations, undef this to save memory */
#define VX1000_OLDA_BENCHMARK

/* Enable Olda overload detection. */
//#define VX1000_OLDA_OVERLOAD_DETECTION

#endif /* VX1000_OLDA */


/*----------------------------------------------------------------------------- */
/* Define parameters for cold start measurement  */

/* Enable VX1000 Detection and Coldstart delay */
/* Note: VX1000 Detection is required for coldstart but will always delay ECU startup by VX1000_DETECTION_TIMEOUT_US */
#define VX1000_DETECTION
#define VX1000_DETECTION_TIMEOUT_US   2000 /* 2 ms */
#define VX1000_COLDSTART_TIMEOUT_MS   100 /* 100 ms */
#define VX1000_COLDSTART_BENCHMARK



// This is used to support sharing DAQ/OLDA table and buffer memory with an XCP on CAN driver
//   If the VX is connected, the XCP drivers DAQ is blocked
//   If XCP on CAN is connected, the VX OLDA is blocked
//   
#define VX1000_DETECT_XCP 



/*----------------------------------------------------------------------------- */
/* Define parameters for stimulation and bypassing */

/* Turn on stimulation and bypassing  */
//#define VX1000_STIM

/* Use indirect stimulation to optimize performance against memory usage */
/* Needs additional memory (amount of bypass data + 4 byte per memory gap) */
//#define VX1000_STIM_BY_OLDA

/* Define the event number range for Bypass events */
/* (Each event needs 4 memory bytes) */
/* (Max number range is 0..31) */
//#define VX1000_STIM_EVENT_OFFSET   0    /* Index of the first STIM event */
//#define VX1000_STIM_EVENT_COUNT    31   /* Number of STIM events used starting at VX1000_STIM_EVENT_OFFSET */

/* Turn on benchmarking of the Bypass round trip time */
//#define VX1000_STIM_BENCHMARK
//#define VX1000_STIM_HISTOGRAM



/*----------------------------------------------------------------------------- */
/* Calibration */

/* Define a FLASH overlay for calibration */
/* Uses the MMU to map the specified RAM over the specified FLASH location */
/* VX1000 uses the mailbox to control page switching, this can also be done via XCP on CAN */

/* Turn on the FLASH overlay */
/* #define VX1000_OVERLAY */
#if defined(VX1000_OVERLAY)

#define VX1000_OVERLAY_ADDR       0x00180000  /* FLASH overlay address */
#define VX1000_OVERLAY_SIZE       0x40000     /* FLASH overlay size 256K */
#define VX1000_OVERLAY_TLB        8           /* Number of the TLB entry used to map CALROM */
#define VX1000_CALRAM_ADDR        0x3FFC0000  /* FLASH overlay RAM address */

/* Use the mailbox to communicate with the XCP on CAN driver */
/* This is used for page switching, copy page and page reallocation */
#define VX1000_MAILBOX
#define VX1000_MAILBOX_OVERLAY_CONTROL
#define VX1000_MAILBOX_PRINTF

/* Use the XCP on CAN calibration page handlers for overlay control */
#define VX1000_GET_CAL_PAGE ApplXcpGetCalPage
#define VX1000_SET_CAL_PAGE ApplXcpSetCalPage
#define VX1000_COPY_CAL_PAGE ApplXcpCopyCalPage

#endif /* VX1000_OVERLAY */





#if 0 /* --- template code start --- */
/*===================================================================== */
/* */
/*  Essential VX1000 macros. */
/* */

/*-------------------------------------- */

/* Define global data needed by VX */
VX1000_DATA

/* Initialize the global data needed for VX1000 */
/* Must be called after reset during initialisation before any other VX1000_xxxx() routine is called !! */
/* VX1000_INIT just initializes VX1000_DATA, if will not use any Tricore or EEC resource */
VX1000_INIT()

/*-------------------------------------- */
/* Measurement data acquisition */

/* Trigger an universal event (OLDA) (0..30) with timestamp */
VX1000_EVENT(DaqEvent)

/*-------------------------------------- */

/* Stimulation and Bypassing */

/* Stimulation control function */
/* Call this periodically in a low priority background task */
VX1000_STIM_CONTROL()

/* Check if stimulation for a stimulation event is turned on (return !=0 true) and bypass */
/* TimeOut is in ms */
/* if (0==VX1000_BYPASS(1, 2, 1000) { function_to_bypass(); } */
r = VX1000_BYPASS(DaqEvent, StimEvent, TimeOut);



/*===================================================================== */
/* */
/* Code instrumentation example: */
/* */


#include "vx1000_mpc5xxx.h"


/* Global data of the VX1000 system */
/* Must be 32bit-aligned! */
/* The memory address of VX1000_DATA (variable gVX1000) must be configured in the VX1000 */
#if 0
/* let the compiler define the VX1000_DATA address */
VX1000_DATA

#else
/* advice the compiler to use a dedicated VX1000_DATA address */

#pragma ghs section bss=".vx1000"
/* VX1000_DATA; -- we had to manually expand the macro to only put gVX1000 into the section, /
/  because when VX1000_OLDA_BENCHMARK_DATA and VX1000_STIM_BENCHMARK_DATA are also included, /
/  the linker sometimes reorders the variables inside and the address of gVX1000 is not as   /
/  desired.                                                                                 */
volatile struct VX1000 gVX1000;
#pragma ghs section bss=default
VX1000_OLDA_BENCHMARK_DATA
VX1000_STIM_BENCHMARK_DATA

#endif


void main( void )
{
   /* Initialize the VX1000 system */
   /* Must be called before any other VX1000_xxx macro is called */
   VX1000_INIT()
   ...
   for (;;)
   {
      ...
      if (task0)
      {
         ...
         /* Measurement     */
         VX1000_EVENT(0) /* Trigger XCP measurement event number 0 */

         /* Bypassing */
         /* Event number 2 is the bypass stimulation event, it indicates that */
         /* the ECU is now waiting for completion of the stimulation */
         /* Event number 1 is the bypass trigger event, it is used to trigger */
         /* calculation of the bypass in the tool, as long as the bypass is */
         /* not activated in the tool, this event is not executed */
         /* 2000 is the timeout in ms, in case of timeout, the original code will not be executed */
         if (0==VX1000_BYPASS(1, 2, 2000))
         {
            /* Original code to be bypassed */
            out = function(in);
         }
      }
      /* Call this macro cyclically outside of any bypassed code. */
      VX1000_STIM_CONTROL()
   }
}

void task1(void)
{
   ...
   /* Measurement */
   VX1000_EVENT(7) /* Trigger XCP measurement event number 7 */
}


/*===================================================================== */
#endif /* --- template code stop --- */


#endif /* !VX1000_MPC5XXX_CFG_H */
